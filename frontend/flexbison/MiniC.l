%{
/* 这里声明语义动作符程序所需要的函数原型或者变量原型或定义等 */
/* 主要包含头文件，extern的全局变量，定义的全局变量等 */

#include <cstdio>
#include <cstdint>
#include <cstring>
#include <string>

// 此文件定义了文法中终结符的类别
// #include "BisonParser.h" // Removing this potentially problematic or redundant include

// AST and Parser related
#include "frontend/AST.h"
#include "frontend/flexbison/autogenerated/MiniCBison.h" 

// Type system related
#include "frontend/AttrType.h"  
#include "ir/Type.h"        
#include "ir/Types/IntegerType.h" 
#include "ir/Types/VoidType.h"    

void yyerror(char * msg);

// 对于整数或浮点数，词法识别无符号数，对于负数，识别为求负运算符与无符号数，请注意。
%}

/* 使它不要添加默认的规则,这样输入无法被给定的规则完全匹配时，词法分析器可以报告一个错误 */
%option nodefault

/* 产生yywrap函数 */
%option noyywrap

/* flex 生成的扫描器用全局变量yylineno 维护着输入文件的当前行编号 */
%option yylineno

/* 区分大小写 */
%option case-sensitive

/* yytext的类型为指针类型，即char * */
%option pointer

/* 生成可重用的扫描器API，这些API用于多线程环境 */
/* %option reentrant */

/* 不进行命令行交互，只能分析文件 */
%option never-interactive

/* 辅助定义式或者宏，后面使用时带上大括号 */

/* 正规式定义 */
DIGIT ([0-9])
ID ([a-zA-Z_]([a-zA-Z_]|[0-9])*)

%%

"("         { return T_L_PAREN; }
")"         { return T_R_PAREN; }
"{"         { return T_L_BRACE; }
"}"         { return T_R_BRACE; }
"["         { return T_L_BRACKET; }
"]"         { return T_R_BRACKET; }

";"         { return T_SEMICOLON; }
","         { return T_COMMA; }

"="         { return T_ASSIGN; }
"+"         { return T_ADD; }
"-"         { return T_SUB; }
"*"         { return T_MUL; }
"/"         { return T_DIV; }
"%"         { return T_MOD; }

">"         { return T_GT; }
">="        { return T_GE; }
"<"         { return T_LT; }
"<="        { return T_LE; }
"=="        { return T_EQ; }
"!="        { return T_NE; }
"&&"        { return T_AND; }
"||"        { return T_OR; }
"!"         { return T_NOT; }

"0"[xX][0-9a-fA-F]+ {
                // 16进制无符号整数
                yylval.integer_num.val = (uint32_t)strtol(yytext, (char **)NULL, 16);
                yylval.integer_num.lineno = yylineno;
                //printf("识别到16进制数: %s = %u\n", yytext, yylval.integer_num.val);
                return T_DIGIT;
            }

"0"[0-7]+   {
                // 8进制无符号整数
                yylval.integer_num.val = (uint32_t)strtol(yytext, (char **)NULL, 8);
                yylval.integer_num.lineno = yylineno;
                return T_DIGIT;
            }

"0"|[1-9][0-9]*	{
                // 词法识别无符号整数，注意对于负数，则需要识别为负号和无符号数两个Token
                yylval.integer_num.val = (uint32_t)strtol(yytext, (char **)NULL, 10);
                yylval.integer_num.lineno = yylineno;
                return T_DIGIT;
            }

"int"       {
                // int类型关键字 关键字的识别要在标识符识别的前边，这是因为关键字也是标识符，不过是保留的
                yylval.type.type = BasicType::TYPE_INT;
                yylval.type.lineno = yylineno;
                return T_INT;
            }

"void"      {
                // void类型关键字 关键字的识别要在标识符识别的前边，这是因为关键字也是标识符，不过是保留的
                yylval.type.type = BasicType::TYPE_VOID;
                yylval.type.lineno = yylineno;
                return T_VOID;
            }

"return"    {
                // return关键字 关键字的识别要在标识符识别的前边，，这是因为关键字也是标识符，不过是保留的
                return T_RETURN;
            }

"if"        {
                // if关键字
                return T_IF;
            }

"else"      {
                // else关键字
                return T_ELSE;
            }

"while"     {
                // while关键字
                return T_WHILE;
            }

"break"     { return T_BREAK; }
"continue"  { return T_CONTINUE; }

[a-zA-Z_]+[0-9a-zA-Z_]* {
                // strdup 分配的空间需要在使用完毕后使用free手动释放，否则会造成内存泄漏
                yylval.var_id.id = strdup(yytext);
                yylval.var_id.lineno = yylineno;
                return T_ID;
            }

[ \t\n]+                  { /* Skip whitespace */ }

"//".*                   { /* Skip single-line comments */ }

"/*"([^*]|(\*+([^*/])))*\*+"/" { /* Skip multi-line comments */ }

.           {
                printf("Line %d: Invalid char %s\n", yylineno, yytext);
                // 词法识别错误
                return 257;
            }

%%
